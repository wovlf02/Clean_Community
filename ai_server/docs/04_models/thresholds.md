# ⚙️ 임계값 설정

> 클래스별 최적화된 임계값과 설정 근거

---

## 📋 개요

멀티라벨 분류에서 **클래스별 최적화된 임계값**을 사용하여 예측 성능을 극대화합니다.

### 임계값이란?
- 앙상블 모델이 출력하는 확률 점수 (0~1)
- 해당 확률이 임계값 이상이면 해당 라벨로 분류
- 클래스마다 다른 임계값 적용 (불균형 데이터 대응)

---

## 📊 현재 임계값 설정

| 라벨 | 임계값 | 설정 근거 |
|------|--------|-----------|
| **여성/가족** | 0.35 | 중간 수준, 오탐 방지 |
| **남성** | 0.22 | 낮은 임계값, 높은 Recall |
| **성소수자** | 0.45 | 높은 임계값, Precision 우선 |
| **인종/국적** | 0.30 | 균형 잡힌 설정 |
| **연령** | 0.30 | 균형 잡힌 설정 |
| **지역** | 0.27 | 약간 낮음, 누락 방지 |
| **종교** | 0.30 | 균형 잡힌 설정 |
| **기타 혐오** | 0.45 | 높은 임계값, 오탐 방지 |
| **악플/욕설** | 0.40 | 중간 높음, Precision 개선 |

---

## 🔍 임계값 결정 원리

### 1. Precision-Recall 트레이드오프

```
높은 임계값 (예: 0.6)
├── ✅ Precision 향상 (오탐 감소)
└── ❌ Recall 감소 (누락 증가)

낮은 임계값 (예: 0.2)
├── ✅ Recall 향상 (누락 감소)
└── ❌ Precision 감소 (오탐 증가)
```

### 2. 클래스별 특성 고려

| 클래스 특성 | 권장 임계값 | 이유 |
|-------------|-------------|------|
| 빈도 높음 | 높은 임계값 | 오탐 영향 큼 |
| 빈도 낮음 | 낮은 임계값 | 누락 방지 우선 |
| 명확한 표현 | 높은 임계값 | 쉽게 탐지됨 |
| 암시적 표현 | 낮은 임계값 | 놓치기 쉬움 |

---

## 📈 라벨별 상세 분석

### 1. 여성/가족 (0.35)

**특성**:
- 비교적 빈번한 혐오 유형
- 명시적 표현과 암시적 표현 혼재
- "김치녀", "맘충" 등 특정 용어 존재

**임계값 근거**:
- 중간 수준으로 균형 유지
- 남성 혐오 문장에서 오탐 방지

### 2. 남성 (0.22)

**특성**:
- 상대적으로 낮은 빈도
- "한남", "6.9" 등 특정 용어
- 다른 라벨과 함께 나타나는 경우 많음

**임계값 근거**:
- 낮은 임계값으로 Recall 우선
- 놓치는 케이스 최소화

### 3. 성소수자 (0.45)

**특성**:
- 명확한 표현이 많음
- 특정 비하 용어 존재
- 오탐 시 민감도 높음

**임계값 근거**:
- 높은 임계값으로 Precision 우선
- 오탐으로 인한 문제 최소화

### 4. 기타 혐오 (0.45)

**특성**:
- 정치 혐오, 계층 혐오 등 포함
- 경계가 모호한 경우 많음
- 학습 데이터 상대적 부족

**임계값 근거**:
- 높은 임계값으로 오탐 방지
- 0.60 → 0.45로 조정하여 Recall 개선

### 5. 악플/욕설 (0.40)

**특성**:
- 일반 욕설과 혐오 구분 모호
- 가장 빈번한 라벨 중 하나
- 정상 문장 오탐 위험

**임계값 근거**:
- 0.36 → 0.40으로 조정하여 Precision 개선
- 정상 문장 오탐 감소

---

## 🔧 임계값 최적화 방법

### 1. 그리드 서치

```python
def find_optimal_threshold(y_true, y_pred_proba, label_idx):
    best_threshold = 0.5
    best_f1 = 0
    
    for threshold in np.arange(0.1, 0.9, 0.05):
        y_pred = (y_pred_proba[:, label_idx] >= threshold).astype(int)
        f1 = f1_score(y_true[:, label_idx], y_pred)
        
        if f1 > best_f1:
            best_f1 = f1
            best_threshold = threshold
    
    return best_threshold, best_f1
```

### 2. 검증 데이터 사용

```python
# 검증 데이터로 최적 임계값 탐색
for label_idx, label_name in enumerate(LABELS):
    threshold, f1 = find_optimal_threshold(y_val, pred_proba, label_idx)
    print(f"{label_name}: threshold={threshold:.2f}, F1={f1:.3f}")
```

---

## 📊 임계값 조정 이력

### 2026.01.31 조정

| 라벨 | 이전 | 현재 | 변경 이유 |
|------|------|------|-----------|
| 기타 혐오 | 0.60 | 0.45 | Recall 0.463 → 0.507 개선 |
| 악플/욕설 | 0.36 | 0.40 | Precision 0.678 → 0.703 개선 |

**결과**:
- Hamming Accuracy: 96.16% → 96.22% (+0.06%p)
- Exact Match: 73.16% → 73.37% (+0.21%p)

---

## 💻 코드에서의 임계값 사용

### constants.py

```python
# 클래스별 최적화된 임계값
THRESHOLDS = {
    "여성/가족": 0.35,
    "남성": 0.22,
    "성소수자": 0.45,
    "인종/국적": 0.30,
    "연령": 0.30,
    "지역": 0.27,
    "종교": 0.30,
    "기타 혐오": 0.45,
    "악플/욕설": 0.40
}
```

### 예측 시 적용

```python
def apply_thresholds(scores: np.ndarray) -> List[str]:
    """확률 점수에 임계값을 적용하여 라벨 결정"""
    labels = []
    for i, label in enumerate(LABELS):
        if scores[i] >= THRESHOLDS[label]:
            labels.append(label)
    return labels
```

---

## ⚠️ 주의사항

1. **임계값 변경 시 전체 테스트 필수**
   - 한 라벨의 임계값 변경이 다른 라벨에 영향 가능

2. **데이터 분포 변화 시 재조정**
   - 새로운 데이터 추가 시 임계값 재검토

3. **비즈니스 요구사항 반영**
   - Precision 우선 vs Recall 우선 결정 필요
   - 오탐 비용 vs 누락 비용 고려
